# Template-Data-Structures
Template Data Structures for reference in future projects.
Featured data structures include Maps (dictionaries from python) queues, stacks, priority-queues(sorted data structure)
Sets(unordered iterable data structure with no duplicates) and eventually graphs(for creating shortest path routes between nodes)
### Features of data structures in these folders that allow them for a wide variety of applications
The data structures in these folders feature certain methods and inherit and override certain operators or classes that allow them to be used for a variety of applications.
1. Iterator: When calling a data structure in `for-each loop` i.e. `for(std::string& s : Queue<std::string> queueString)` or methods or using methods that can use `Iterable` objects it is best to create a `private: class Iterator` class in the class declaration of your template data structure. Also when creating a method that can take and use an object that contains "multiple items" it is best to make the paramter declaration `const Iterable& i`. With these kinds of declaration your methods and other data structures can be implemented and operate with varieties of various objects. With an Iterator class it makes accessing each item simple and straightforward which can make writing methods that make debugging strings or output streams much easier since every item of the data structure can be accessed without having to worry about making unwanted changes to private member variables. Some methods in the Iterator class are: 
  * <strong>!= and ==</strong> operators: For comparing and contrasting items as well as to check if the end condition or marker is reached
  * <strong> * and -></strong> operators: For deferencing the iterators or accessing methods and properties of objects themselves. Iterators just representing markers within a data structure. The items themselves can be of any item and can be complex objects themselves! To get access to the actual value, the *() will be used to dereference that value ->() is used to access properties and methods that the object that the iterator is pointing to has. The dereference usually returns a value wheil the -> returns an address usually.
  * <strong> ++ and ++(int)</strong>: Prefix and Postfix operators are used to increment and navigate through the data structure until the endpoint is reached. <em> Note </em>: These operators only allow FORWARD Iteration for backwards iteration the --() operators need to be overloaded(this will also likely require additional instance variables in the Iterator class in the form of a prev pointer)
  * <strong> .begin() and .end() </strong>: begin() and end() methods that used by the outside class that will create the Iterators. begin() marks the beginning of the structure and its first item. end() is usually either a null pointer or a pointer to an out of bounds array index depending on the implementation.
  * <strong> ::erase() </strong> The erase method will permanently delete the iterator's OBJECT from the structure. From here the iterator will still exists but be considered invalid and raise an exception when trying to dereference it. Also to get back to the regular data structure, one incremented by calling ++ to move past the erased index.
  *<strong> Fields: can_erase(boolean);mod_count:(int);</strong>ref(pointer to actual data structure)
2. size(): This method returns the size of the structure in terms of the number of items it has. Usually the length is cached in terms of a private instance value `int used = 0;` which gets modified on insertion or removal of items.
3. empty(): Returns a boolean that determines if a structure has items in it or not.
4. clear(): Clears and deallocates, if necessary, all the items and memory from the structure and leaves it empty but leaves it in a state where it can still be operated on and modified back. Usually this method is good for the destructor operator.
5. = and (const Structure& copystructure): Assignment and copy constructor. Method that will clear and if need be, deallocate, all items in the left hand side and copy all the items and instance variables from the right hand structure to the left in an efficient manor.
6. == and != : Equality operators to test if every item in one structure is the same as every other structure's items. Depending on the type of structure, order is a key factor as well. Normally structures with different sizes (call .size() or used) are considered not equal.
7. ostream operator: Used to create a standard output string to represent an object, iterator's come in handy for implementing these operators.
8. insert/enqueue_all(const Iterable& i): Inserts all items in an Iterable data structure to the structure referenced in `this`. Can also be used as constructor options as well.
9. `[const KEY& key] operator -> Item item(Maps only)` : The bracket operator overload provides a shorthand notation for Map-like objects to access the items and values represented by their KEY fields in the pair.
10. Strcuture::contains(Item& i): Checks if the structure has a certain item  in it, more useful once the structure is used in outside implementations. Such as Sets in the graph implementation.
11. `<, <=, >,>=` Operators (Only for Sets): Used to test the amount of items two sets can share, the equality part means they are of the same size and have ALL the same values. < denotes left hand side shares all of its members with the right, but right hand has more members in total, some of which do not belong to the left. The > and >= are just the opposite or negation of (!) of < and <= respectively, and can be written as return !(this > rhs) or !(this >= rhs) once the other operators are defined
12. `int used; int mod_count;` : Private instance variables that can be used to cache size and modification count.
13. `bool (*cgt) gt(const T& a, const T& b);` gt or sorting function for priority queues, this function used in priority-queues provides a user-defined way to determine which items have priority with in the structure.
  
